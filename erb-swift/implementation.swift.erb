// DO NOT MODIFY!
// Generated by mb-ormapper generator ver <%= VER %>
// https://github.com/tmurakam/mb-ormapper

import Foundation

class <%= cdef.base_class_name %> : ORRecord {

<%
  cdef.members.each do |m|
    type, mem = getObjcType(m.type)
-%>
    var <%= m.prop_name %> : <%= type %>
<% end -%>

    override init() {
        super.init()
    }

    /**
     @brief Migrate database table
     @return YES - table was newly created, NO - table already exists
     */
    class func migrate() -> Bool {
        let columnTypes: [String] = [
<% cdef.members.each do |m| -%>
            "<%= m.field_name %>", "<%= getSqlType(m.type) %>",
<% end -%>
        ]

        return super.migrate(columnTypes, primaryKey:"<%= PKEY %>")
    }

    // MARK: -  Read operations

    /**
      @brief get the record matchs the id
      @param pid Primary key of the record
      @return record
    */
    class func find(pid: Int) -> <%= cdef.class_name %>? {
        let db = Database.instance()

        let stmt = db.prepare("SELECT * FROM <%= cdef.table_name %> WHERE <%= PKEY %> = ?;")
        stmt.bindInt(0, val: pid)

        return find_first_stmt(stmt)
    }

<%
  cdef.members.each do |m|
    type, mem = getObjcType(m.type)
-%>
    /**
      finder with <%= m.field_name %>

      @param key Key value
      @param cond Conditions (ORDER BY etc)
      @note If you specify WHERE conditions, you must start cond with "AND" keyword.
    */
    class func find_by_<%= m.field_name %>(key: <%= type %>, cond: String?) -> <%= cdef.class_name %>? {
        let cond2 : String  
        if (cond == nil) {
            cond2 = "WHERE <%= m.field_name %> = ? LIMIT 1"
        } else {
            cond2 = "WHERE <%= m.field_name %> = ? \(cond!) LIMIT 1"
        }
        let stmt = gen_stmt(cond2)
        stmt.bind<%= getMethodType(m.type) %>(0, val:key)
        return find_first_stmt(stmt)
    }

    class func find_by_<%= m.field_name %>(key: <%= type %>) -> <%= cdef.class_name %>? {
        return find_by_<%= m.field_name %>(key, cond:nil)
    }

<% end -%>

    /**
      Get first record matches the conditions
      @param cond Conditions (WHERE phrase and so on)
      @return array of records
    */
    class func find_first(cond: String?) -> <%= cdef.class_name %>? {
        let cond2: String
        if (cond == nil) {
            cond2 = "LIMIT 1"
        } else {
            cond2 = cond! + " LIMIT 1"
        }
        let stmt = gen_stmt(cond2)
        return  find_first_stmt(stmt)
    }

    /**
      Get all records match the conditions
      @param cond Conditions (WHERE phrase and so on)
      @return array of records
    */
    class func find_all(cond: String?) -> [<%= cdef.base_class_name %>] {
        let stmt = gen_stmt(cond)
        return  find_all_stmt(stmt)
    }

    /**
      create dbstmt
      @param s condition
      @return dbstmt
    */
    class func gen_stmt(cond: String?) -> dbstmt {
        let sql: String
        if (cond == nil) {
            sql = "SELECT * FROM <%= cdef.table_name %>;"
        } else {
            sql = NSString(format:"SELECT * FROM <%= cdef.table_name %> %@;", cond)
        }  
        let stmt = Database.instance().prepare(sql)
        return stmt
    }

    /**
      Get first record matches the conditions
      @param stmt Statement
      @return array of records
    */
    class func find_first_stmt(stmt: dbstmt) -> <%= cdef.class_name %>? {
        if (stmt.step() == SQLITE_ROW) {
            // e = [[self class] new]
            let e = <%= cdef.class_name %>()
            e._loadRow(stmt)
            return e
        }
        return nil;
    }

    /**
      Get all records match the conditions
      @param stmt Statement
      @return array of records
    */
    class func find_all_stmt(stmt: dbstmt) -> [<%= cdef.base_class_name %>] {
        var array : [<%= cdef.base_class_name %>] = []

        while (stmt.step() == SQLITE_ROW) {
            //let e = self.class().new()
            let e = <%= cdef.class_name %>()
            e._loadRow(stmt)
            array.append(e)
        }
        return array;
    }

    func _loadRow(stmt: dbstmt) {
        self.pid = stmt.colInt(0)
<%
    i = 1
    cdef.members.each do |m|
      type = m.type
      method = "col" + getMethodType(type)
-%>
        self.<%= m.prop_name %> = stmt.<%= method %>(<%= i %>)
<%    i += 1 -%>
<%  end -%>
    }

    // MARK: - Create operations

    override func _insert() {
        super._insert()

        let db = Database.instance()
    
        //db.beginTransaction()
<%
  arglist = ""
  cdef.members.each do |m|
    arglist += ",?"
  end
-%>
        let stmt = db.prepare("INSERT INTO <%= cdef.table_name %> VALUES(NULL<%= arglist %>);")
<%
    i = 0
    cdef.members.each do |m|
      method = "bind" + getMethodType(m.type)
-%>
        stmt.<%= method %>(<%= i %>, val:self.<%= m.member_name %>)
<%    i += 1 -%>
<%  end -%>
        stmt.step()

        self.pid = db.lastInsertRowId()

        //db.commitTransaction()

        db.setModified()
    }

    // MARK: - Update operations

    override func _update {
        super._update()

        let db = Database.instance()
        //db.beginTransaction()

        let stmt = db.prepare("UPDATE <%= cdef.table_name %> SET "
<%
  isFirst = true
  cdef.members.each do |m|
    if (isFirst)
      isFirst = false
-%>
        + "<%= m.field_name %> = ?"
<%  else -%>
        + ",<%= m.field_name %> = ?"
<%  end -%>
<% end -%>
        + " WHERE <%= PKEY %> = ?;")
<% 
    i = 0
    cdef.members.each do |m|
      method = "bind" + getMethodType(m.type)
-%>
        stmt.<%= method %>(<%= i %>, val:self.<%= m.member_name %>)
<%
      i += 1
    end
-%>
        stmt.bindInt(<%= i %>, val:self.pid)

        stmt.step()
        //db.commitTransaction()

        db.setModified()
    }

    // MARK: - Delete operations

    /**
      Delete record
    */
    override func delete() {
        let db = Database.instance()

        let stmt = db.prepare("DELETE FROM <%= cdef.table_name %> WHERE <%= PKEY %> = ?;")
        stmt.bindInt(0, self.pid)
        stmt.step()

        db.setModified()
    }

    /**
     Delete all records
    */
    class func delete_cond(cond: String?) {
        let db = Database.instance()

        if (cond == nil) {
            cond = ""
        }
        let sql = NSString(format:"DELETE FROM <%= cdef.table_name %> %@;", cond)
        db.exec(sql)

        db.setModified()
    }

    override class func delete_all {
        <%= cdef.base_class_name %>.delete_cond(nil)
    }

    /**
     * get table sql
     */
    class func getTableSql(s: NSMutableString) {
        s.appendString("DROP TABLE <%= cdef.table_name %>;\n")
        s.appendString("CREATE TABLE <%= cdef.table_name %> (key INTEGER PRIMARY KEY")

<% cdef.members.each do |m| -%>
        s.appendString(", <%= m.field_name %> <%= m.type %>")
<% end -%>    
        s.appendString(");\n")

        let ary = find_all(nil)
        for (e in ary) {
            e.getInsertSql(s)
            s.appendString("\n")
        }
    }

    /**
     * get "INSERT" SQL
     */
    func getInsertSql(s: NSMutableString) {
        s.appendFormat("INSERT INTO <%= cdef.table_name %> VALUES(%ld", (long)self.pid)
<% cdef.members.each do |m| -%>
        s.appendString(",")
        s.appendString(quoteSqlString(<%= getToString(m.type, m.member_name) %>))
<% end -%>
        s.appendString(");")
    }

    // MARK: - Internal functions

    override class func tableName -> String {
        return "<%= cdef.table_name %>"
    }
}

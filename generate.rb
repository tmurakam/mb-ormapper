#!/usr/bin/ruby

require "schema.rb"

VER = "0.1"

def getObjcType(type)
    case type
    when "INTEGER"
        return "int", "assign"
    when "REAL"
        return "double", "assign"
    when "TEXT"
        return "NSString*", "retain"
    when "DATE"
        return "NSDate*", "retain"
    else
        puts "#{type} is not supported."
        exit 1
    end
end

def getMethodType(type)
    case type
    when "INTEGER"
        return "Int"
    when "REAL"
        return "Double"
    when "TEXT"
        return "String"
    when "DATE"
        return "Date"
    else
        puts "#{type} not supported"
        exit 1
    end
end

# generate header
def generateHeader(cdef, fh)
    fh.puts <<EOF
// Generated by O/R mapper generator ver #{VER}

#import <UIKit/UIKit.h>

@interface #{cdef.name} : NSObject {
    int id; // primary key
EOF

    cdef.members.each do |m|
        type, mem = getObjcType(cdef.types[m])
        fh.puts "    #{type} #{m};"
    end

    fh.puts <<EOF

    BOOL isInserted;
}

@property(nonatomic,assign) int id;
EOF
    
    cdef.members.each do |m|
        type, mem = getObjcType(cdef.types[m])
        fh.puts "@property(nonatomic,#{mem}) #{type} #{m};"
    end

    fh.puts <<EOF

+ (BOOL)migrate

+ (NSMutableArray *)find_all:(const char *)cond;
+ (NSMutableArray *)find_cond:(const char *)cond;
+ (#{cdef.name} *)find:(int)id;
- (void)save;
- (void)delete;

// internal functions
- (void)_insert;
- (void)_update;
- (void)_loadRow:(dbstmt *)stmt;

@end
EOF

end

# generate implementation
def generateImplementation(cdef, fh)
    fh.puts <<EOF
// Generated by O/R mapper generator ver #{VER}

#import "Database.h"
#import "#{cdef.name}.h"

@implementation #{cdef.name}

@synthesize id;
EOF

    cdef.members.each do |m|
        fh.puts "@synthesize #{m};"
    end
    fh.puts

    fh.puts <<EOF
- (id)init
{
    self = [super init];
    isInserted = NO;                         
    return self;
}

- (void)dealloc
{
EOF
    
    cdef.members.each do |m|
        type, mem = getObjcType(cdef.types[m])
        if (mem == "retain")
            fh.puts "    [#{m} release];"
        end
    end
    
    fh.puts <<EOF
    [super dealloc];
}

/**
  @brief Migrate database table

  @return YES - table was newly created, NO - table already exists
*/

+ (BOOL)migrate
{
    Database *db = [Database instance];
    dbstmt *stmt;
    
    // check if table exists.
    stmt = [db prepare:@"SELECT sql FROM sqlite_master WHERE type='table' AND name='#{cdef.name}';"];
    if ([stmt step] != SQLITE_ROW) {
        [db exec:@"CREATE TABLE #{cdef.name} ("
            "id INTEGER PRIMARY KEY"
EOF
    
    cdef.members.each do |m|
        fh.puts "            \", #{m} #{cdef.types[m]}\""
    end

    fh.puts <<EOF
            ");"
         ];
        return YES; // created
    }

    // check migration
    NSString *tablesql = [stmt colString:0];
    NSRange range;
EOF
    
    cdef.members.each do |m|
        fh.puts <<EOF
    range = [tablesql rangeOfString:@" #{m} "];
    if (range.location == NSNotFound) {
        [db exec:@"ALTER TABLE #{cdef.name} ADD COLUMN #{m} #{cdef.types[m]}"];
    }
EOF
    end

    fh.puts <<EOF

    return NO;
}

/**
  @brief get all records
  @return array of all record
*/
+ (NSMutableArray *)find_all
{
    return [self find_cond:nil];
}

/**
  @brief get all records matche the conditions

  @param cond Conditions (WHERE phrase and so on)
  @return array of records
*/
+ (NSMutableArray *)find_cond:(NSString *)cond
{
    NSMutableArray *array = [[[NSMutableArray alloc] init] autorelease];
    Database *db = [Database instance];
    dbstmt *stmt;

    NSString *sql;
    if (cond == nil) {
        sql = @"SELECT * FROM #{cdef.name};"
    } else {
        sql = [NSString stringWithFormat:@"SELECT * FROM #{cdef.name} %@;", cond];
    }  

    stmt = [db prepare:@sql];
    while ([stmt step] == SQLITE_ROW) {
        #{cdef.name} e = [[[#{cdef.name} alloc] init] autorelease];
        [e _loadRow:stmt];
        [array addObject:e];
    }
    return array;
}

/**
  @brief get the record matchs the id

  @param id Primary key of the record
  @return record
*/
+ (#{cdef.name} *)find:(int)id
{
    Database *db = [Database instance];

    dbstmt *stmt = [db prepare:@"SELECT * FROM #{cdef.name} WHERE id = ?;"];
    [stmt bindInt:0 val:id];
    if ([stmt step] != SQLITE_ROW) {
        return nil;
    }

    #{cdef.name} e = [[[#{cdef.name} alloc] init] autorelease];
    [e _loadRow:stmt];
 
    return e;
}

- (void)_loadRow:(dbstmt *)stmt
{
    self.id = [stmt colInt:0];
EOF

    i = 1
    cdef.members.each do |m|
        type = cdef.types[m]
        method = "col" + getMethodType(type)
        fh.puts "    self.#{m} = [stmt #{method}:#{i}];"
        i += 1
    end
    
    fh.puts <<EOF

    isInserted = YES;
}

/**
  @brief Save record
*/
- (void)save
{
    if (isInserted) {
        [self _update];
    } else {
        [self _insert];
    }
}

- (void)_insert
{
    Database *db = [Database instance];
    dbstmt *stmt;
    
    [db beginTransaction];
EOF

    fh.print "    stmt = [db prepare:@\"INSERT INTO #{cdef.name} VALUES(NULL"
    cdef.members.each do |m|
        fh.print ",?"
    end
    fh.print ");\"];\n"
    fh.puts

    i = 0
    cdef.members.each do |m|
        method = "bind" + getMethodType(cdef.types[m])
        fh.puts "    [stmt #{method}:#{i} val:#{m}];"
        i += 1
    end

    fh.puts <<EOF
    [stmt step];

    self.id = [db lastInsertRowId];

    [db commitTransaction];
    isInserted = YES;
}

- (void)_update
{
    Database *db = [Database instance];
    [db beginTransaction];

    dbstmt *stmt = [db prepare:@"UPDATE #{cdef.name} SET "
EOF
    cdef.members.each do |m|
        fh.puts "        \"#{m} = ?,\""
    end
    
    fh.puts "        \" WHERE id = ?;\"];"

    i = 0
    cdef.members.each do |m|
        method = "bind" + getMethodType(cdef.types[m])
        fh.puts "    [stmt #{method}:#{i} val:#{m}];"
        i += 1
    end
    fh.puts <<EOF
    [stmt bindInt:#{i} val:id];

    [stmt step];
    [db commitTransaction];
}

/**
  @brief Delete record
*/
- (void)delete
{
    Database *db = [Database instance];

    dbstmt *stmt = [db prepare:@"DELETE FROM #{cdef.name} WHERE id = ?;"];
    [stmt bindInt:0 val:id];
    [stmt step];
}

@end
EOF

end

# start from here
if (ARGV.size != 1)
    STDERR.puts "usage: #{$0} [deffile]"
    exit 1
end

schema = Schema.new
schema.loadFromFile(ARGV[0])
#schema.dump

# generate
schema.defs.each do |cdef|
    STDERR.puts "generate #{cdef.name}.h"
    fh = open(cdef.name + ".h", "w")
    generateHeader(cdef, fh)
    fh.close

    STDERR.puts "generate #{cdef.name}.m"
    fh = open(cdef.name + ".m", "w")
    generateImplementation(cdef, fh)
    fh.close
end
